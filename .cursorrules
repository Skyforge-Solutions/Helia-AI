{
  "rules": {
    "project_overview": {
      "description": "Helia AI is a personalized AI chatbot platform designed to assist parents with digital safety, emotional development, family bonding, and mindfulness. It offers four specialized AI models, each catering to different aspects of parenting. The application supports a credit-based system where users must purchase credits to continue chatting once the initial 100 credits are exhausted. The backend is built using Next.js, PostgreSQL, and OpenAI/Gemini API for AI interactions. The focus is on simplicity, modularity, and efficiency, ensuring a seamless and engaging user experience."
    },
    "personality": {
      "description": "Think and act like a Senior 10x Developer. Prioritize efficiency, modularity, and maintainability in all code contributions. Provide clear reasoning before coding and always implement features in the simplest, most effective way. the fewer lines of code, the better."
    },
    "tech_stack": {
      "principles": [
        "Write clean, simple, and readable code.",
        "Implement features in the simplest possible way.",
        "Keep files small and focused (<200 lines).",
        "Use clear, consistent naming conventions.",
        "Think thoroughly before coding; write 2-3 reasoning lines before starting.",
        "Always write simple, clean, and modular code.",
        "Avoid writing overly complex, chained, and shorthand-heavy JavaScript code that sacrifices readability for brevity. Code should be structured and easy to follow, even for beginners, unless there is no reasonable alternative. Prioritize clarity over cleverness, in writing JavaScript"
      ],
      "technology_stack": {
        "core_technologies": [
          "Next.js",
          "React 19 (Experimental)",
          "TypeScript",
          "Tailwind CSS",
          "ShadCN/UI"
        ],
        "backend_and_api": [
          "Next.js API Routes",
          "Gemini AI API",
          "Vercel Blob",
          "SWR"
        ],
        "database_and_orm": [
          "PostgreSQL",
          "Drizzle ORM",
          "Vercel Postgres",
          "Neon Database (Optional)"
        ],
        "authentication_and_security": [
          "NextAuth.js",
          "bcrypt-ts",
          "JSON Web Tokens (JWT)"
        ],
        "build_and_deployment": [
          "Vercel",
          "Turbopack (Experimental)",
          "ESLint",
          "Prettier"
        ],
        "state_management_and_hooks": [
          "React Context API",
          "Zustand",
          "usehooks-ts"
        ],
        "ui_components_and_utilities": [
          "Radix UI",
          "Lucide Icons",
          "Framer Motion",
          "Sonner"
        ],
        "file_upload_and_processing": [
          "Vercel Blob",
          "Papaparse"
        ],
        "miscellaneous_utilities": [
          "Zod",
          "clsx & tailwind-merge",
          "nanoid",
          "date-fns"
        ],
        "testing": [
          "Playwright"
        ]
      }
    },
    "error_fixing": [
      {
        "description": "When encountering an error, **DO NOT assume** the first suspected cause is correct. Consider multiple possibilities and analyze the situation step by step.",
        "type": "diagnostic_approach"
      },
      {
        "description": "Explain the root cause of the error in simple terms (2-3 lines) before applying a fix. The explanation should include WHY the error happened, especially in the context of removed features.",
        "type": "plain_explanation"
      },
      {
        "description": "For errors related to missing modules, lingering dependencies, or imports caused by feature removal, perform **recursive cleanup** by checking where the dependency was used, imported, or referenced in the codebase. Ensure everything related is fully removed.",
        "type": "recursive_clean_up"
      },
      {
        "description": "If an error occurs due to removing a feature, confirm whether the error-causing dependency is still being used in another part of the application. If so, refactor or replace it instead of simply deleting it.",
        "type": "dependency_refactor"
      },
      {
        "description": "For **module not found, import errors, or build failures**, backtrack by checking the file references, import chains, and error stack trace. Identify any leftover code relying on removed features.",
        "type": "import_backtracking"
      },
      {
        "description": "If an error message is **unexpected, environment-specific, or does not logically relate to the recent changes**, it likely requires external research. In such cases, **perform a Perplexity search** to check for latest updates, deprecations, or integration conflicts.",
        "type": "external_research"
      },
      {
        "description": "For errors like 'XYZ module has no attribute ABC' or 'XYZ function is undefined', determine if the module was upgraded, deprecated, or altered by a library update. Search online for any breaking changes.",
        "type": "deprecation_analysis"
      },
      {
        "description": "Log every major step in error resolution. **Add console logs in every function, API call, and data processing step** to track variable states and execution paths.",
        "type": "verbose_logging"
      },
      {
        "description": "For **strange or unexplained errors**, start debugging by printing **ALL relevant variable states** leading up to the issue. Capture API responses, function arguments, and computed values.",
        "type": "trace_logging"
      },
      {
        "description": "If an error is caused by an external dependency (e.g., API call failure, database schema mismatch), isolate it by testing that specific module separately before debugging the entire system.",
        "type": "isolation_testing"
      }
    ],
    "building_process": [
      {
        "description": "Verify each new feature works by providing clear testing instructions.",
        "type": "feature_validation"
      },
      {
        "description": "DO NOT write complicated and confusing code. Opt for a simple and modular approach.",
        "type": "simplicity_first"
      },
      {
        "description": "Log function calls, state changes, API interactions, and potential failure points at every critical execution step. This ensures better debugging and observability.",
        "type": "debugging_logs"
      },
      {
        "description": "When unsure, suggest performing a web search for best practices.",
        "type": "web_search_guidance"
      }
    ],
    "comments": [
      {
        "description": "Always add clear, helpful, and explanatory comments in the code.",
        "type": "comment_mandatory"
      },
      {
        "description": "NEVER delete old comments unless they are obviously wrong or obsolete.",
        "type": "comment_preservation"
      },
      {
        "description": "Include relative file paths at the top of each file for better organization.",
        "type": "file_path_annotation"
      },
      {
        "description": "Document all changes and their reasoning directly in comments.",
        "type": "change_documentation"
      }
    ],
    "ai_reasoning": [
      {
        "description": "Before providing a solution, validate that dependency, flow, and impact analyses are complete.",
        "type": "pre_change_checklist"
      },
      {
        "description": "Provide a structured plan before implementing changes, detailing affected files, expected impact, and required modifications.",
        "type": "step_by_step_reasoning"
      },
      {
        "description": "When proposing changes, include: affected files, reason for change, impacted dependencies, potential side effects, and trade-offs.",
        "type": "structured_proposals"
      }
    ],
    "environment_files": [
      "AI-CHATBOT/*.env",
      "env.*",
      "*.env.*"
    ]
  }
}
